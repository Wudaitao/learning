# TCP基础知识

## tcp头部格式
![tcp头部格式](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843ZPb6tFLvCVuXEn98khfs7y2KRvOV0ia5icVByzIK3aAKRURuVZKagsKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
主要有：
**源端口号** ：用于标识发送数据的上层应用

**目的端口号** : 用于标识接收数据的上层应用

**序列号** : 在建立连接时由计算机生成的随机数作为初始值。通过SYN包传给接收端主机，每发送一次数据，序列号就会累加一次该**数据字节数**的大小，**用来解决网络包乱序问题**。

**ack确认应答号** ：指下一次期望接收的数据的序列号，发送端收到这个确认应答后可以认为在这个序号以前的数据都已经被正常接收，**用来解决不丢包的问题**。

**控制位**：
- ACK:除建立连接时的SYN包之外，该位必须置1，表示ack确认应答号字段生效。
- SYN:该位置1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定
- RST:该位置1表示TCP连接中出现异常必须强制断开连接
- FIN:该位置1表示不再发送数据，希望断开连接



## TCP协议工作在哪层？为什么需要TCP协议
<div align=center>
    <img src="https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843tzTAWL4l6rZB0pulNqkLno7buMqnh5Hlphn7aibB798ga1t3a0Dqmzg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" width="XXX" height="XXX" />
</div>

### TCP最大报文段长度 MSS
### IP最大传输单元MTU（以太网中一般为1500字节）

**只有应用层是工作在操作系统中的用户态，传输层及以下都工作在内核态**

**TCP工作在传输层**
由于网络层的IP协议是不可靠的，它不保证网络能够按序交付，也不保证网络包中数据的完整性。所以如果需要保证网络数据包的可靠性，就需要上层提供一个可靠的传输协议**TCP**。因为TCP是一个工作在传输层的面向连接的，可靠的数据传输服务。能够保证接收端接收的数据包是无损坏、无间隔、非冗余和按序的

## 什么是TCP
TCP是面向连接的、可靠的、基于字节流的传输层协议
- **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- **可靠的**：无论网络链路出现了怎样的变化，TCP都可以保证网络数据包一定能按序无差错的到达接收端
- **字节流**：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。

## 什么是TCP连接
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小称为连接。**
 - **Socket**：由IP和端口号组成
 - **序列号**：用来解决乱序问题
 - **窗口大小**：用来进行流量控制

## UDP和TCP有什么区别？分别的应用场景？
UDP不提供复杂的控制机制，不能保证数据可靠传输，利用IP协议提供的面向无连接的通信服务。UDP协议非常简单，头部只有固定的**8**个字节，UDP的格式如下：
![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8431Mymq2yPGjMPGodSEg8b31eoyQbibzGjDEHiaQUUDlbvCEwcXN3aicOTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

### TCP与UDP的差别
1. **连接**
 - TCP是面向连接的传输层协议，传输数据前需要建立连接
 - UDP是不需要建立连接的，即刻传输数据
2. **服务对象**
 - TCP是一对一的两点服务，一条连接只有两个端点
 - UDP支持一对一，一对多，多对多的交互通信
3. **可靠性**
 - TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达
 - UDP则是尽最大努力交付数据，不保证数据的可靠性
4. **拥塞控制和流量控制**
 - TCP有拥塞控制和流量控制机制，保证数据传输的安全性
 - UDP没有，即使网络异常拥塞了，也不会影响UDP的发送速率

### TCP和UDP的应用场景
由于TCP面向连接，提供可靠性的数据交付，通常用于：
- FTP文件传输
- HTTP/HTTPS

由于UDP面向无连接，可以随时发送数据，处理简单且高效，常用于：
- 包总量较少的通信，如：DNS、ARP、SNMP等
- 视频、音频等多媒体通信
- 广播通信

## TCP连接建立
TCP是面向连接的协议，使用TCP前需要建立连接，即通过**三次握手**建立
![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843fFol7gd3035Kibg3gPMSAZQLVibf9nwEblOUaX80hoOaRLVpaYCAI44w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
最初，客户端和服务器端都处于CLOSEED状态，先是服务器端主动监听某个端口，处于LISTEN状态
1. 第一个报文：客户端将SYN位置1,并随机初始化序列号为【client_seq】，接着将SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于**SYN_SEND**状态
2. 第二个报文：服务器收到客户端的连接请求SYN报文，首先服务端也随机初始化自己的序列号【server_seq】，然后ack确认应答号设为【client_seq+1】，接着将SYN和ACK标志置为1.最后将该报文发送给客户端，该报文也不包含应用层数据，之后服务器处于**SYN_RCVD**状态
3. 第三个报文：客户端收到服务端的报文后，最后还需向服务端回应最后一个应答报文。ACK标志置1，ack=server_seq+1，seq = client_seq+1;这次报文可以**携带客户端到服务端的数据**，之后客户端处于**ESTABLISHED**状态
服务端收到客户端的应答报文后，也进入**ESTABLISHED**状态

## 为什么需要三次握手，而不是两次、四次？
这个问题即是：为什么需要三次握手才可以初始化Socket、序列号和窗口大小并建立TCP连接。有三个方面的原因：
- **三次握手才能阻止历史连接初始化了连接（主要原因）**
  ![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS8436nKau10lAsztRqbyhjC1C1GRcsEz04icZmomMjwcxgeGn97BnKUoxibw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
  网络环境不稳定可能造成旧的连接请求数据包比新的连接请求数据包先到达目标主机，这种情况客户端就会在第三次握手时，放弃此次连接，发送RST报文给服务端，终止这一次连接。
- **三次握手才可以同步双方的初始序列号**
  ![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843HWajXhQQfx6CH4EUxLqib0AAOXolZfIvuoEDkDoXaQ3RIceibo8ia9MQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
  通信双方必须维护一个序列号，序列号是TCP能够可靠传输关键因素，所以客户端和服务端都需要确保双方的初始序列号被可靠的同步，客户端向服务端发送了序列号，需要服务端回复ACK，服务端也需要向客户端发送序列号，并要求得到客户端的ACK，所以理论上需要四次，但是由于服务端可以将回复ACK和同步序列号合并成一步，所以只需要三次握手
  而两次握手只能保证客户端的初始序列号能够被对方成功接收，而不能保证服务端的初始序列号被客户端确认接收。
- **三次握手才可以避免资源浪费**
  ![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843CaTeGEvR5jg3iaHbUTEroayMBUoK3yfy9zGwlIia8pJu8x4RDkDGFLicg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
  如果只有两次握手，那么服务端只要接收到客户端的SYN报文就会建立起一个连接，从而建立了多个冗余的无效链接，造成不必要的资源浪费。

## SYN队列和Accept队列
 在客户端发起连接请求时，第一次握手，1.server端接收到了SYN请求，创建socket,存储于SYN Queue（半连接队列），并向客户端返回SYN+ACK. 2.server端接收到了第三次握手的ACK，socket状态更新为ESTABLISHED，同时将socket移动到Accept Queue（全连接队列），等待应用执行accept();

## 什么是SYN攻击，如何避免？
**SYN攻击**：由于TCP连接需要三次握手，所以攻击者可以在短时间内伪造不同IP地址的SYN报文发送给服务端，服务端每次接收到一个SYN报文，就进入到SYN_RCVD状态，但服务端发送出去的ACK+SYN报文始终得不到未知IP地址的ACK应答，长时间过后**占满了服务端的SYN接收队列**，使得服务端不能为正常用户提供服务

避免SYN攻击方式1：
- 一种解决方式是通过修改Linux内核参数，控制队列大小和当队列满时应该做什么处理
- 如果不断受到SYN攻击，就会导致SYN队列被占满，设置tcp_syncookies的方式可以应对SYN攻击

## TCP连接断开
TCP断开连接是通过四次挥手的方式，双方都可以主动断开连接，断开连接后主机中的资源将被释放
![](https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeo9xBVAyPJ8iaWCC6sYS843KaMMu2mHfFLZNgiaREDZ5JicRYrlaiciayQjh9HDsacxIbMT0emGUpAX5w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 客户端发起关闭连接请求，向服务端发送FIN报文，FIN标志位置1，之后客户端进入FIN_WAIT_1状态
- 服务端收到该报文后，向客户端发送ACK应答报文，然后服务端进入CLOSED_WAIT状态。
- 客户端收到服务端的ACK报文后，进入FIN_WAIT_2状态
- 等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态
- 客户端收到服务端的FIN报文后，回复一个ACK应答报文，进入TIME_WAIT状态。
- 服务端收到了ACK应答报文后，进入CLOSE状态，服务端至此完成了连接的关闭
- 客户端在经过2MSL时间后，自动进入CLOSE状态，客户端至此也完成了连接的关闭
**每个方向都需要一个FIN和一个ACK**，因此通常称为四次握手

## 为什么需要TIME_WAIT状态，且时间为2MSL?
MSL是报文最大生存时间，它是任何报文在网络上存在的最长时间，超过该时间的报文将被丢弃。TIME_WAIT 等待2倍的MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。
需要TIME_WAIT状态，主要两个原因：
- 防止具有相同连接的【旧】数据包被收到：因为存在延迟的数据包，如果没有TIME_WAIT状态或者等待时间不足，相同端口的TCP连接被复用后，延迟的数据包到达了客户端，那么客户端就有可能正常接收这个过期的报文，导致数据错乱等严重的问题。
- 保证连接正确关闭：即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；

## 如果建立了连接，客户端突然出现了故障怎么办？
TCP有一个**保活机制**，在一定时间段内，如果没有任何连接相关的活动，TCP保活机制会每隔一个时间间隔，发送一个探测报文，去探测客户端的存活情况，如果连续多个探测报文都没有得到响应，则认为当前TCP连接已经死亡，断开此次连接。
linux内核有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，默认值如下：
net.ipv4.tcp_keepalive_time=7200(2小时)
net.ipv4.tcp_keepalive_intvl=75(探测间隔为75秒)
net.ipv4.tcp_keepalive_probes=9(连续检测的次数)
## TCP如何保证可靠的数据传输
### 重传机制
  超时重传：在一定时间内（加权往返时间+4*偏差时间）没有收到接收方的应答，则重传数据
  快速重传：连续收到三次同一个报文的ACK应答，立即重传该报文
  两者的区别在于超时重传是以时间为驱动，而快速重传是以数据为驱动
### 滑动窗口
  解决的问题：发送一次数据，就必须等待一次应答才能再发数据的效率太低下
  可用窗口大小就是指无需等待确认而可以发送数据的最大值，接收端告诉发送端自己还有多少缓冲区可以接收数据，发送端就可以根据接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以发送端的窗口大小是由接收端缓冲区决定的。
### 流量控制
流量控制是为了避免【发送方】的数据填满【接收方】的缓存，利用滑动窗口实现，接收端在返回的数据中包含自己的接收窗口大小，以控制发送方的数据发送
### 拥塞控制
拥塞控制是为了避免发送方的数据填满整个网络，是在已经出现了网络拥塞时，采用降低发送数据量的方式，疏散拥堵。
原则是：只要网络未出现拥堵，拥塞窗口就增大一些，一旦出现拥堵，就将窗口减小，以减少注入到网络中的数据。
两种实现方式：
- 慢启动+拥塞避免
 1. 慢启动：开始时将拥塞窗口设为1，每次收到一个应答时就将拥塞窗口扩大一倍，指数增长
 2. 拥塞避免：拥塞窗口到达阈值后，每收到一个确认，窗口大小+1执行加法增长
 3. 当有一次没有收到确认应答后就将拥塞窗口的阈值降为当前窗口的一半，拥塞窗口初始化为1，继续执行慢启动和拥塞避免过程

- 快重传+快恢复
 1. 快重传：发送方连续三次接收到重复的应答报文，说明有数据丢失，需立即重发该丢失报文
 2. 快恢复：当接收到三次重复应答报文，阈值降为当前窗口大小的一半，并将拥塞窗口设置为阈值+3，再执行加法增长
 
# IP协议
IP在TCP/IP参考模型中属于第三层，即网际层，其主要作用：实现主机与主机之间的通信，也叫点对点通信，**在复杂的网络环境中将数据包发送给最终目的主机**

## 网络层（IP）和数据链路层（MAC）之间的区别和关系
IP的作用是主机之间通信，而MAC的作用是实现直连的两个设备之间通信，而IP则负责在没有直连的两个网络之间进行通信传输。**源IP地址和目标IP地址在传输过程中是不会变化的，只有源 MAC 地址和目标 MAC 一直在变化**


# HTTP协议
## HTTP基本概念
  HTTP是一种超文本传输协议，用于在两点之间传输文字，图片，视频，音频等超文本数据的约定和规范
## HTTP常见状态码，有哪些？
![](https://segmentfault.com/img/remote/1460000021948305)
### 1XX
1XX类状态码属于提示信息，是协议处理中的中间状态，实际用到的比较少
### 2XX
2XX类状态码表示服务器成功处理了客户端的处理请求
【200 ok】是最常见的成功状态码，表示一切正常
【204 No Content】也是最常见的成功状态码，与200 ok基本相同
【204 Partial Content】是应用于HTTP分块下载和断点续传
### 3XX
3XX类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，表示**重定向**
【301】永久重定向，说明资源已经不存在了，需改用新的URL访问
【302】临时重定向，说明资源还在，但是需要用另一个URL来访问
【304】重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制
### 4XX
4XX类状态码表示客户端发送的报文有误，服务器无法处理
【400】客户端请求的报文有错误，但未说具体错误
【403】表示服务端禁止访问资源，并不是客户端请求出错
【404】表示请求的资源在服务端找不到，无法提供给客户端
### 5XX
5XX状态码表示服务端内部发送了错误
【500】表示服务端出错，但是并未具体说明什么错
【501】表示客户端请求的功能还不支持
【503】表示服务端正忙，暂时无法处理客户端的请求
## GET和POST
### GET和POST的区别
Get方法是请求从服务端获取资源，如静态的文本、页面、图片视频等，需要将请求的内容添加到URL的对应字段中，暴露了隐私 （数据只支持ASCII编码）
Post方法是相反操作，它向URL指定的资源提交数据，数据是封装在请求报文的body里，不会暴露数据隐私 (对数据类型没有限制，允许二进制数据)
### GET和POST方法是安全且幂等的吗？
安全和幂等的概念：
- 在HTTP协议中，安全是指请求方不会破坏服务器上的资源
- 幂等是指无论执行多少次相同的操作，最终的结果都是相同的
所以GET方法是安全幂等的，因为它是只读操作，不修改服务器上的数据，而POST则不是

## 交换机与路由器的区别
- 路由器可以为局域网自动分配ip，指挥数据包该往哪里走，而交换机只是将数据按照规定的映射表分发网络数据
- 路由器工作在TCP/IP协议的网络层，根据IP地址寻址，而交换机工作在数据链路层，根据MAC地址寻址
- 路由器用于在不同网络之间转发数据，而交换机是在特定网络内将数据转发到不同的端口
- 路由器具有自学习功能，能够学习mac地址对应的收发端口