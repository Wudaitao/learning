秋招准备
=======

**自我介绍**

** 面试官，您好！我叫伍代涛，本科和研究生就读于重庆大学计算机学院，本人在专业技能方面，能够掌握基本的算法和数据结构，熟悉基本的计算机网络协议，掌握常用的编程语言，同时了解分布式系统相关知识。本人研究生期间的方向是分布式存储，在研究生入学之前就参加了实验室的分布式存储项目，该项目针对移动环境中网络资源受限，存储节点状态动态变化的特点，实现高可靠性的移动分布式存储系统，我的主要贡献是，作为小组负责人，参与设计了项目中心化与去中心化的混合存储架构，两次参与项目验收答辩。同时还负责项目中元数据持久化的设计与实现以及基于纠删码的冗余机制和数据自适应布局方案的设计与实现，最后负责搭建测试平台，设计测试方案，测试在移动条件下系统的读写性能。除了该项目之外，在自己学习redis的过程中，仿照redis的跳表实现了一个轻量级的键值存储引擎，具有读写删除等功能，经过测试，在64核的服务器上，平均每秒的读写请求可到20W以上。
在个人品格上，本人具有较强的学习和解决问题的能力，吃苦耐劳，对工作和生活都乐观积极，敢于面对苦难和挑战，勇于承担责任。
以上就是我的基本情况，谢谢面试官!
**

**项目难点**

1.传输文件，使用的是零拷贝技术，减少了系统调用，用户态和内核态切换的次数，从原始的四次变成了2次，同时减少了数据的拷贝次数，将磁盘中的数据通过DMA拷贝到内核缓冲区PageCache后，再通过网卡的SG-DMA直接将数据拷贝到网卡的ringBuffer中，不需要经过用户缓冲区，提高文件传输效率
小文件采用sendfile
大文件采用异步IO+直接IO

2.管理节点上元数据的持久化，两种策略，定时将内存中的元数据dump到磁盘中，具体方法是fork一个子进程，在子进程中将元数据dump下来。如果在此过程中，还有元数据生成，就将写元数据的操作缓存下来，一并写入元数据操作的log文件中，从而在重启时先加载dump下来的整个元数据，然后再加载log文件的操作，就可以创建元数据信息

3.难点在于主进程和子线程间通过管道通信，主进程接收到任务时，需要指定一个线程去执行这个任务，并把这个任务放到线程的任务队列里，主进程将任务放到线程的任务队列后，需要向管道写入C，触发线程的epoll（epoll侦听的是管道fd）来读取管道，读取管道时会将管道内的数据全部读出，并触发命令的处理函数

问题：当多个任务到来，主进程将他们分配到一个任务线程去执行，主进程向任务线程同时写入多个C，而epoll唤醒后会读取管道中的所有数据，只触发一次命令的处理函数

控制读一个C执行一次命令的处理函数或绕过epoll处理机制，直接调用处理函数

# 操作系统

操作系统是什么？操作系统是管理计算机硬件与软件资源的计算机程序。主要包括进程管理、内存管理、文件管理、设备管理

## 进程管理
程序是进程的载体，是本文代码段，而进程是执行中的程序，是活动的实体，包括文本、数据、堆栈等信息

**进程PCB**

进程状态、程序计数器、CPU寄存器、CPU调度器、内存管理信息、记账信息、I/O状态信息

**进程状态切换**

* 新建（new）：进程正在被创建
* 就绪（ready）:进程准备就绪，等待分配处理器
* 运行（running）:指令正在CPU中运行
* 等待（waiting）:进程等待某个事件的发生（如IO完成或者事件等待）
* 终止（exit）:进程运行完毕，结束运行

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg)

**进程切换**

* 实质是被中断进程和待执行进程的上下文切换、而上下文切换则会保存被中断进程的PCB，恢复另一个进程的PCB
* 切换和中断的区别：会修改被中断进程和待执行进程的进程控制块（PCB），并把被中断进程的PCB加入相关队列
* 流程：
	* 保存CPU现场，修改被中断进程和待执行进程的PCB
	* 根据中断向量表分析中断原因，中断向量表保存每种中断类型所对应的中断处理程序的入口地址
	* 将控制权交给相应的中断处理程序并处理中断
	* 中断处理完后修改被中断进程和待执行进程的PCB，恢复CPU现场，继续执行（<font color="red">被中断指令的地址被保存在程序计数器中，以便继续执行</font>）

**进程状态切换的时机**

进程状态切换一定发生在中断、异常、系统调用处理过程中，常见有一下情况：

* 阻塞式系统调用，虚拟地址异常，导致被中断使进程进入等待态
* 时间片中断、I/O中断后发现更优先级进程。进程进入就绪态
* 终止系统调用，不能继续执行的异常，进程进入终止态

**进程上下文切换到底切换了什么？**
<font color="red">进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。总结起来就是，用户空间和内核空间资源的切换</font>

**进程调度**

操作系统的调度程序选择一个进程在CPU上运行的功能，叫做CPU的调度，在进程的生命周期中，当进程从一个运行状态到另外一状态变化的时候，会触发一次调度。

调度时机：

* 从就绪态 -> 运行态：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行
* 从运行态 -> 阻塞态：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行
* 从运行态 -> 结束态：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行

调度算法：

* FCFS先来先服务调度算法：非抢占，先到先服务，对长作业有利，对短作业不利
* SJF最短作业优先调度算法：非抢占，选最短CPU运行时间的进程，对短作业有利，不利于长作业，有助于提高系统的吞吐量
* 最短剩余时间优先调度算法
* 高响应比优先调度算法
* 时间片轮转调度算法：抢占式，为分时系统设计，固定时间片，每个进程都获得一个时间片的cpu，循环调度
* 高优先级调度算法：抢占或非抢占，将cpu分配给优先级高的进程
* 多级反馈队列调度算法：进程可以在队列间移动以改变优先级，占用CPU高的移动到低优先级队列，而长时间得不到cpu的移动到高优先级

**协程**

linux系统的跳转方法：

* setjmp/longjmp：长跳，可以实现跨函数栈间的跳转，但是只能在进程内部跳转，不能跨进程（c接口实现）
* ucontext:可以实现进程上下文间的跳转（linux系统提供的接口）
* 自己使用汇编实现，通过汇编指令操作CPU寄存器，来实现进程中上下文的切换，将CPU中当前运行协程的上下文寄存器值暂时保存，然后再将即将要运行的上下文寄存器加载到CPU中相应的寄存器上，从而完成协程切换。（协程的底层实现原理）


大量的进程/线程出现了新的问题：
* 系统线程会占用非常多的内存空间
* 过多的线程和进程切换占用系统时间，开销很大

协程刚好可以解决上诉问题，协程运行在线程之上，当一个协程执行完成后，可以选择主动退出，让另一个协程运行在当前线程之上。<font color="red">协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态切换到内核态的代价要小很多</font>

协程，又称微线程。协程在执行过程中，可在内部进行中断，然后转而执行别的协程，在适当的时候返回来接着执行，这种在一个协程中中断去执行另一个协程的方式，看起来像是函数调用，其实是CPU的中断

**僵尸进程、孤儿进程**

**僵尸进程**：

父进程fork子进程，子进程退出时会释放资源但是保留进程描述符，标识进程id及退出时的状态，运行时间；父进程需要调用wait或者waitpid获取子进程描述符才能知道该进程退出时的状态，如果父进程没有wait，则子进程的描述符一直在系统中，变成僵尸进程；僵尸进程用ps打印会显示z，僵尸进程是每个子进程必须要经过的阶段；

**孤儿进程**：

父进程退出，但是它的子进程还在运行，这些子进程会成为孤儿进程，孤儿进程由init进程（进程id为1）收集他们的状态

**shell实现原理**

shell是操作系统内核提供给用户的接口，不属于内核，而是在内核之外以用户态方式运行，解释执行用户输入的各种命令，实现用户与内核的接口
实现原理：

- linux系统启动后，内核会为每个终端用户建立一个进程执行shell程序，首先读取用户键盘输入的命令
- 对命令进行解析，以命令名为文件名，并将其他参数改造成系统调用execve()函数处理所要求的格式
- shell进程调用fork()或者vfork()建立一个子进程，子进程根据文件名在目录中查找可执行文件，调入内存并创建新的文本段，同时根据写时拷贝的方式创建相应的数据段和堆栈
- 当子进程完成处理或者出现异常后，通过exit()向父进程报告，终端进程调用wait()函数等待子进程完成，并对子进程进行资源回收

**进程间通信方式**

|---|---|----|---|----|----|
|匿名管道|命名管道|信号|信号量|共享内存|消息队列|socket|
|半双工通信，消息缓存在内核中，读写内核需要进行用户态和内核态的切换，执行很慢，效率低，<font color="red">只能用于具有亲缘关系（父子进程）的进程之间通信</font>，传输少量数据，当管道没有空闲空间或没有内容读取时都会阻塞|给管道命名，和匿名管道的区别是<font color="red">可用于没有亲缘关系的进程间通信</font>,提前创建了一个类型为管道的设备文件，使用该文件就可以通信|通知进程产生了某个事件。<font color="red">信号是进程间通信机制中唯一的异步通信机制</font>。因为可以在任何时候发送信号给某一进程，一旦信号产生，对应进程将作出相应处理|用于进程间同步，若要在进程间传递数据需要结合共享内存.<font color="red">P和V两个原子操作，对资源进行减1和加1.信号初始化为1，代表互斥信号量，保证只有一个进程在访问共享内存.信号初始化为 0，代表同步信号量 (写者必须在读者之前执行)</font>|分出一块内存供进程间读写数据，<font color="red">读写数据均相当于内存访问，是通信方式中最快的一种</font>，只是实现复杂一般结合信号量实现同步互斥|消息队列是保存在内核中的消息链表，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。不适用于传输数据较大的情况|网络通信机制，用于不同主机之间进行通信|

**详细说说共享内存**

* <font color="blue">什么是共享内存</font> 共享内存是进程间通信的一种方式。不同进程之间共享的内存通常为同一段物理内存，进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。
* <font color="blue">共享内存的优点</font> 因为所有进程共享同一块内存，共享内存在各种进程间通信方式中具有最高的效率。访问共享内存区域和访问进程独有的内存区域一样快，并不需要通过系统调用或者其它需要切入内核的过程来完成。同时它也避免了对数据的各种不必要的复制。
* <font color="blue">共享内存的缺点</font> 共享内存没有提供同步机制，这使得我们在使用共享内存进行进程之间的通信时，往往需要借助其他手段来保证进程之间的同步工作。

**fork系统调用**   /底层技术：读时内存共享，写时内存复制/

用于父进程创建子进程，如果返回值小于0，则创建失败，如果返回值大于0则是父进程在执行，并且返回的是子进程的PID，如果等于0表示的是子进程在运行

fork子进程后有两种执行状态：

* 父进程和子进程并发执行
* 父进程等待子进程执行完成

子进程的地址空间有两种可能：

* 子进程是父进程地址空间的拷贝，拥有相同的代码和数据
* 子进程调用另一个程序，覆盖原有地址空间

**fork、vfork、clone**

fork,vfork,clone都是linux的系统调用，这三个函数分别调用了sys_fork、sys_vfork、sys_clone，最终都调用了do_fork函数，差别在于参数的传递和一些基本的准备工作不同，主要用于linux创建新的子进程或线程（vfork创造出来的是线程）。

|----|----|
|系统调用|描述|
|fork|fork创造的子进程是父进程的完整副本，复制了父亲进程的资源，包括内存的内容task_struct内容|
|vfork|vfork创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行|
|clone|Linux上创建线程一般使用的是pthread库 实际上linux也提供了创建线程的系统调用，就是clone|

**线程**

线程是进程中一条执行流程，多个线程共享进程中的代码段，数据段，打开的文件描述符等资源，但每个线程都有自己独立的寄存器和栈

**线程和进程的区别**

* 进程是操作系统资源分配的基本单位，而线程是CPU调度的基本单位
* 进程拥有完整的资源，包含文本，数据，堆栈等数据，而线程只独享寄存器，计数器和栈
* 线程能够减少并发执行的时间和空间开销，其上下文切换比进程快，因为同一个进程的线程之间共享内存，具有同一个页表，在切换的时候不需要切换页表，而进程之间的切换，需要切换页表，页表的切换过程开销很大，还需要清空TLB，导致查询页表缓存失效

**线程池**

实现原理：维护一个工作线程队列和一个任务队列，线程池不断从任务队列中选择任务分配给工作线程去执行。 

为什么需要线程池？ ： 传统的创建释放线程开销大，并且并发请求多时，默认线程是无限创建的，会耗尽系统资源；线程池通过创建固定数目的线程，并保证线程一直在运行等待时间的到来，减少了新建线程的时间延时，限制了线程数目。线程池的线程数目：CPU密集型：cpu核+1；I/O密集型：cpu核/cpu利用率

**死锁**

* 概念：多个并发进程因为抢夺系统资源而产生的相互等待的现象。
* 必要条件：1）互斥2）占有并等待3）不可抢占4）循环等待
* 解决方法：1）死锁预防：破坏必要条件；2）死锁避免：银行家算法；3）死锁检测与恢复

**互斥和同步**

* 互斥是指某一资源同时允许一个访问者对其进行访问，具有唯一性和排他性，但互斥无法限制访问者对资源的访问顺序
* 同步是在互斥的基础上，通过同步机制保证对资源的访问是有序的

**线程同步**

|--|
|自旋锁|互斥锁|读写锁|悲观锁|乐观锁|条件变量|
|通过while循环一直占用CPU,直到加锁成功，适用于占用锁时间较短的场景，属于悲观锁|多个线程在竞争资源时，加锁失败的线程会被阻塞，当其他线程执行完后，释放锁，唤醒阻塞线程，有两次上下文切换，切换开销较大，适用于占用锁时间长的情况，属于悲观锁|读写锁同一时间内只允许一个写者，但是允许多个读者同时读取对象，属于悲观锁|倾向于多线程同时修改共享资源的概率比较高，于是数据很容易冲突，所以访问共享之前需要先上锁，应用于修改比较频繁的场景|在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作，适用于读多写少的场景|条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待"条件变量的条件成立"而挂起；另一个线程使"条件成立"（给出条件成立信号）|

## 内存管理

**虚拟内存**

将逻辑内存和物理内存分开，允许进程不全部放在内存中，允许进程大于物理内存

优点：将更大的逻辑内存映射到物理内存；允许进程在物理内存中不连续，利用碎片；节省物理内存，如共享页；

缺点：各个进程需要建立存储页表，占用一定磁盘空间，增加对磁盘的读写

1. 物理内存 以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于 CPU 的地址线条数。比如在 32 位平台下，寻址的范围是 2^32 也就是 4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给 4G 物理内存，就可能会出现很多问题： - 因为物理内存是有限的，当有多个进程要执行的时候，都要给 4G 内存，很显然内存不够，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作效率很低 - 由于指令都是直接访问物理内存的，那么任何进程都可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是不安全的 
2. 虚拟内存 由于物理内存有很多问题，所以出现了虚拟内存。虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换

**分页，分段，段页式**

* 分页：将逻辑内存划分为固定大小的页，将物理内存划分为相同大小的帧，每页4KB，没有外部碎片，因为粒度较小换入换出效率高
* 分段：将逻辑内存和物理内存划分为不固定大小的段，每个进程占用一个段，有内部碎片和外部碎片，且因为粒度大换入换出效率低
* 段页式：逻辑内存分段，段内再分页，再将物理内存分为大小相同的页，每页大小为4KB，没有外部碎片，保留了分段和分页的全部优点

**缺页异常处理步骤**

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E6%B5%81%E7%A8%8B.png)

* 在CPU里访问一条load M指令，然后CPU会去找M对应的页表项
* 如果在页表项中的状态是【有效的】，则直接访问物理内存，如果状态位是【无效的】，则CPU会发送缺页中断处理请求
* 操作系统受到缺页中断后，执行相应的缺页中断函数，先查找该页面在磁盘中的位置
* 找到在磁盘中对应的页面后，需要把该页面换入到物理内存中，检查是否有空闲内存页，如果没有还需要执行内存页面置换
* 页面从磁盘换入到物理内存完成后，将页表项中的状态位修改为【有效的】
* 最后，CPU重新执行导致缺页异常的指令

**页面置换算法**

* 最佳页面置换算法：选择在未来长时间不用的页换出，但是不现实
* 先进先出置换算法：先进来的页面在换出时最先出去，但是会导致系统颠簸，总是出现频繁缺页的情况，频繁调用置换算法
* LRU最近最少使用置换算法：性能较好，但是开销较大，实际应用中很少使用
* 时钟页面置换算法：
* 最不常用置换算法；考虑最近访问次数最少的那个页面被换出

**系统调用和库函数的区别**

从宏观上说，系统调用是内核层，C标准库在应用层。从细节上来说，在linux中，C标准库基本是对系统调用的包装，例如我们常见的printf，putc，fwrite等等，其实去看源码可以发现内部都有使用系统调用write函数，而且系统调用是操作系统的特性，不兼容，而库函数是编程语言的特性，考虑了不同操作系统的兼容性

**系统调用的处理流程**

系统调用是一种软件中断。软件中断和我们常说的硬件中断不同之处在于，硬件中断指硬件通过总线向CPU发起中断请求，而软件中断是指通过软件指令即系统调用来触发中断。

* 保护cpu现场
* 分析中断原因
* 将控制权交给中断处理程序，并由用户态切换到内核态，由内核执行系统调用对应的中断处理程序
* 中断处理完后将控制权交给用户应用程序，并切换回用户态，用户应用程序恢复CPU现场，继续执行之前的指令

**用户态和内核态的区别**

* 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。
* 这两种状态的主要差别是

	1.处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所占有的处理器是可被抢占的

	2、处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

**同步与异步、阻塞与非阻塞**

同步和异步关注的是**消息通信机制**

* 同步就是发出一个调用，需要等待其结果返回，异步就是执行了一个调用，不用等待结果返回，可以先去做其他事情，等到有结果后再通过回调通知调用者来处理该调用

阻塞与非阻塞关注的是**程序在等待调用结果时的状态**

* 阻塞调用是调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之前才会返回，非阻塞调用是指在不能得到结果之前，该调用不会阻塞当前线程

**用户态和内核态的切换**

三种方式会导致切换：系统调用，硬件中断、异常

切换过程：

* 进程陷入内核态后，保存用户态堆栈地址到内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，完成用户态向内核态的转换
* 进程从内核态恢复到用户态执行时，将内核栈里的用户栈地址恢复到堆栈指针寄存器上，实现内核栈到用户栈的切换

**为什么epoll使用红黑树而不是hash表来管理文件描述符**

* 因为hash表在数据扩容时，会进行重hash，而重hash这个过程是一笔巨大运算，导致性能突然变差，出现抖动的情况，而红黑树在插入删除时不会出现这种情况，性能稳定.所以每次epoll_ctl的时间应该是平均的。
* hash表虽然是o(1)时间复杂度，但是网络连接数很大时，底层的哈希冲突很大并且扩容频繁

**epoll为什么选择红黑树而不选择平衡树**

* 单次插入二者没有太大差别
* 删除的时候，红黑树快，而平衡树需要维护树的平衡，极端情况下回到O(logn)
* 在大量增删的情况下，因为平衡树严格要求高度平衡，所以在增删的时候需要调整的概率就变大了，而红黑树放宽了限制，不需要频繁调整保持高度平衡

## linux调试工具
* 段错误：gdb+coredump日志  gdb 可执行文件名(如clay) core文件名
* 内存泄露：valgrind   valgrind --tool=memcheck --leak-check=full --error-limit=no ./main
* 指针越界：make 编译选项加-fsanitize=address
* 进程被kill：dmesg命令查看日志，大概率是内存泄漏
* 系统错误：errno 是记录系统的最后一次错误代码，如#define EINTR 4 /* Interrupted system call */
* gdb attach pid命令的使用：b（打断点）、r（运行）、n（往下执行多少行）、s（跳入函数内部）、bt（查看堆栈信息） gdb -quiet -batch -ex='thread apply all bt' -p pid      thread apply all bt：查看所有线程的堆栈信息
* 线程栈的运行情况：pstack pid 可查看进程当前所有线程运行栈情况
* 查看22号端口被哪个进程占用或者查看22号进程在监听哪个端口：netstat -anp|grep 22

## 如何读取一个10G文件，cat一个10g文件会发生什么
10G的 log 里面每一行都保存着一个url，内存只有250M，当输入一个url时，如果快速查出日志里是否有这条记录，如果有，有多少条？要求不能使用数据库，只能使用文本处理。

先将10g文件切分成小于250M的小文件，split -l 500000 10G.log  (按行切分成40个大小为250M的文件)，然后对每个文件使用grep命令搜索指定url并写入到一个文件中，grep -i $TARGET_URL $file >> $TARGET_FILE 最后使用wc命令统计行数 
cat $TARGET_FILE | wc -l

## 文件编译过程
![](https://img-blog.csdnimg.cn/2020070511101976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dKUUpGSg==,size_16,color_FFFFFF,t_70)
预处理->编译->汇编->链接成可执行文件


## 网络编程的一般过程

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/tcp_socket.png)

服务端：
* 服务器端调用socket函数创建套接字，创建网络协议IPv4
* 然后调用bind()绑定端口号和IP地址
* 调用listen()开始监听连接到来的客户端
* 调用accept()函数,从内核中回去客户端的连接，如果没有客户端连接，一直阻塞直到连接到来
* 开始read()和write()
客户端：
* 创建socket套接字
* 调用connet函数连接
* 开始write()和read()


# c++

## 指针与引用的区别

* 相同点：都是地址的概念，指针是指向对象的内存地址，引用则是内存的一个别名
* 不同点：
	* 本质:指针是一个实体，在内存需要分配地址空间，而引用只是一个别名，不需要分配地址空间
	* 指针在初始化时可以为空，而引用初始化时不能为空，必须关联一个对象，一旦绑定了对象则不能更改，相当于T *const ptr，指针常量
	* 自增含义:指针自增表示下一个地址空间，而引用自增表示引用的变量加1
	* sizeof大小：sizeof 指针表示指针本身的大小，在不同平台大小不一致，32位平台为4，64位平台为8，而sizeof引用则是引用对象的大小
	* 引用是类型安全的，而指针不是，引用比指针多了类型检查
	* 指针作为函数参数传递时传递的是指针变量的值，而引用作为函数参数传递时传递的是实参本身，而不是拷贝副本
	* 本质上可以将引用理解成一个指针常量，不能改变自身的值，但是能够改变引用对象的值

## static关键字的用法和作用
  static 是一个关键字，可以用来修饰局部变量、全局变量、成员变量、函数和成员方法。主要作用有：限制数据的作用域、延长数据的生命周期、修饰成员可以被该类所有对象共享。

* 告知编译器将变量存放在静态存储区而不是栈或者对上（编译时初始化）
* 同时编译多个文件时，没有加static的全局变量都是全局可见的，在别的文件中可以通过extern关键字调用，而加了static关键字修饰的变量作用域只能在本文件中，可以解决命令冲突的问题
* 延长数据的生命周期，普通局部变量在出了作用域后就会被释放，而静态变量存储在静态区，直到程序结束才会被释放
* 静态成员可以被该类的所有对象共享，节约内存，它是属于类的，而不是属于某个特定的对象，可以通过类名直接访问
* 静态变量默认初始化值为0，如果没有显示初始化静态变量或者初始化为0的静态变量会存储在BSS段，而显示初始化的静态变量存储在DATA段
* 静态成员函数中不能访问普通的成员变量，只能访问静态成员变量，并且在静态成员函数中没有 this 指针

## const关键字的用法和作用
  const关键字可以修饰变量，指针，函数参数，成员方法，表示不可修改的意思

* 用在变量上，表示变量只读，而不能更改其值
* 修饰指针，有常量指针 `const int * ptr`，表示指针指向的变量不能更改其值；有指针常量`int * const ptr`，表示指针本身不能修改，其所指向的内容可以修改；`const int * const ptr`,指向常量的指针常量，指针本身不能变，指向的值也不能更改
* 修饰函数参数，表示所传参数在函数内部不允许被更改
* 修饰成员方法，表示不能在方法中修改非static成员
* 修饰成员变量，类的成员变量可以分为静态的和非静态的，如果 const 修饰的是非静态的成员变量，可以在构造函数中对该变量进行初始化；如果 const 修饰的是静态的成员变量，则需要在类外对该变量进行初始化。

## const和define的区别
const表示只读，禁止对const常量进行修改操作，define用于定义宏，而宏定义也可以定义常量，区别在于

* 宏定义define在预处理阶段生效，而const是在编译阶段生效
* define只是简单的字符串替换，不具备类型检查的功能，而const有对应的数据类型，会在编译期进行检查
* define定义的常量不可以用指针变量去指向它，而const常量可以去指向该常量的地址
* define不分配内存，是立即数，不会加入符号表，有多少次就在内存中有多少拷贝，内存开销大，const在静态存储区中分配空间，运行时只有一个拷贝

## volatile关键字的用法和作用
 volatile关键字修饰的变量，表示易变的，指的是对于编译器而言，禁止编译器对改变量进行优化操作，让CPU每次读取改变量都从内存中读取，而不是去寄存器上读

* Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。
* Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。
* Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。

## const和volatile可以一起使用吗
volatile 限定符是用来告诉计算机，所修饰的变量的值随时都会进行修改的。用于防止编译器对该代码进行优化。通俗的讲就是<font color='red'>CPU在用到这个变量时必须每次都小心地从内存中重新读取这个变量的值，而不是使用保存在寄存器里的备份。 const 和 volatile 可以一起使用，volatile 的含义是防止编译器对该代码进行优化，这个值可能变掉的。而 const 的含义是在代码中不能对该变量进行修改。因此，它们本来就不是矛盾的。</font>

## 虚函数的实现原理 （虚表和虚函数表指针）
每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着虚函数表的指针。「虚函数表」中列出了该类的「虚函数」地址。

当一个类A具有虚函数时，编译器就会为类A生成一个虚成员函数表（vtable），该表是一个一维数组，存放着类中每个虚函数的入口地址。同时还在类A中生成一个隐藏成员变量vptr,其值是虚函数表的起始地址，从而根据vptr找到虚函数表，然后根据偏移在虚函数表中找到相应的虚函数

当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。

## 内联函数
内联函数在编译时将所有运用内联函数的地方替换为相应代码块，是编译时确定的，避免了函数调用的开销，但是可执行代码变大。<font color="red">虚函数可以是内联函数,当使用明确的对象调用虚函数时，可以内联，但是当虚函数变现出多态性时，即通过基类指针或引用调用虚函数时，不能内联，因为多态是运行时机制，而内联是编译时机制</font>

## 构造函数不能为虚函数，析构函数需要为虚函数

* 虚函数用于实现运行时多态，虚函数表是在构造函数内初始化的，构造函数如果为虚函数，会导致该类无法初始化一个对象
* 析构函数如果不设置成虚函数，在多态情况下，通过删除基类指针不会析构基类指向的子类，导致内存泄漏

## STL（标准模板库）
六大组件： 算法、容器、适配器、迭代器、仿函数、内存分配器

* 容器：各种数据结构，包括序列式容器，vector，list，deque，array，顺序关联式容器，map,set,multimap,multiset，非顺序关联式容器，unordered_map,unordered_set
* 算法：各种常用算法，sort,reverse,accumulate,copy.从实现的角度来看，STL算法是一种 funct* ion template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)
* 适配器：一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应
* 迭代器：容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator- - 等指针相关操作进行重载的class template
* 仿函数：行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。
* 内存分配器：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。

## 容器和容器适配器
* 序列式容器：

	vector-基于数组，元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。 内存空间连续，随机访问性能好O(1)，插入删除性能差O(n),适用于数据少，大量查找的场景、
    
	list－基于双向链表，动态申请内存，内存空间不连续，随机访问性能差O(n),插入删除性能好O(1)，适用于大量插入和删除的场景
    
	deque-分段连续，通过中央控制器map(并非map容器)，记录着一系列的固定长度的数组的地址.记住map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。
	![](https://uploadfiles.nowcoder.com/images/20220226/4107856_1645863128559/94350469A991E848BE934DC7665EF04F)
* 关联式容器：
	
	map,multimap,set,multiset:基于红黑树，存取查找都是O(logn)，适用于有序要求

	unordered_map,unordered_set：基于哈希表，具体实现为数组加链表，链地址法，1）存：hash(key)得到槽号，将key，value放入与槽相关联的链表（可以使用各种规则来排序）中；2）取：根据hash(key)获取槽号，查询链表，是否有对应的key，再获取value

* 容器适配器：
	
	stack:基于deque,栈先进后出

	queue:基于deque,队列先进先出 （还可以基于链表，但是由于链表的地址空间不连续，导致cache失效，数据预取正确率下降）

	priority_queue:基于堆，最大堆最小堆排序

## 容器内部元素的删除
* 顺序容器：通过erase删除迭代器不仅使所指向的迭代器失效，而且使被删元素之后的所有迭代器失效，不可以使用erase(it++)的方式，但是可以用it = erase(it）的方式删除一个迭代器然后获得下一个迭代器
* 关联式容器：通过erase删除迭代器只会使被删除元素的迭代器失效，返回值为void,可以采用erase(it++)的形式删除迭代器

## c++中struct和class的异同
* struct能够包含成员函数，构造和析构函数、能够包含虚函数和纯虚函数，能够实现多态，但是默认访问和继承方式为public,class默认访问和继承方式都是private，这点体现出面向对象的封装性，
* class可以作为模板类的参数，但是struct不可以

## c/c++内存分配
操作系统中，每个进程在虚拟内存中的分区布局从高地址到低地址如下：

* 栈区：由编译器自动分配释放，一般栈区的大小是固定的，linux系统中为8M,主要存放函数的参数值，局部变量的值，函数返回值，其操作方式类似于数据结构中的栈。 不会产生内存碎片，分配的效率高
* 文件映射区（mmap）:用于存放文件映射到内存中的地址
* 堆区：由程序员调用malloc主动申请和释放的内存区域
* 全局区/静态区：全局变量和静态变量存储区域，初始化的全局变量和静态变量在.data区，未初始化或者初始化为0的全局和静态变量存放在.bss区,生命周期为整个程序的运行时期
* 常量区：存放字符串常量，数值，程序结束后由系统释放
* 程序代码区：存放可执行文件的二进制代码。（并不是从0地址开始的，逻辑地址的0地址处是不被使用的）

## 空类的大小
* 空类的大小是1，c++ 要求对于每个类的实例都要有独一无二的地址，编译器会自动为空类分配一个字节大小，这样子保证了每个实例均有独一无二的地址
* 带有虚函数的空类不为1，因为具有虚函数的类实例化对象具有指向虚函数表的vptr

## 空类具有的默认函数
* 缺省构造函数
* 拷贝构造函数
* 析构函数
* operator=赋值运算符重载函数
* operator&取地址运算符重载函数

## c++四种类型转换
从低到高是自动转换（隐式转换），从高到低需要强制转换（显示转换）

* static_cast：任意两种类型之间的强制转换
* dynamic_cast:运行时检测类型转换是否安全，原类型必须是多态类型
* const_cast:将指向常量对象的指针强制转换成非常数对象的指针
* reinterpret_cast：修改指针类型或将指针类型转换为int或将int转换为指针类型